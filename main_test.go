package iabtcf

import (
	"reflect"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
)

// all consent strings generated by: https://iabtcf.com/#/encode
func TestConsentMethods(t *testing.T) {
	tests := []struct {
		name                       string
		c                          string
		wantPurposes               map[int]bool
		wantSpecialFeatures        map[int]bool
		wantVendor                 int
		wantPurposesAllowed        bool
		wantSpecialFeaturesAllowed bool
		wantVendorAllowed          bool
		publisherCountry           string
		wantVersion                int
		wantErr                    bool
	}{
		{
			"empty",
			"",
			nil,
			nil,
			0,
			true,
			true,
			true,
			"AA",
			0,
			true,
		},
		{
			"v1 string #1",
			"BOv1FaTOv1FdvAHABBFRDG-AAAAvRr_7__7-_9_-_f__9uj3Or_v_f__32ccL59v_h_7v-_7fi_20nV4u_1vft9yfk1-5ctDztp507iakivXmqdeb1v_nz3_5pxP78k89r7337Ew_v8_v-b7BCON9YxEiAAA",
			nil,
			nil,
			0,
			false,
			false,
			false,
			"",
			1,
			true,
		},
		{
			"10 purposes and 2 special features allowed, vendor allowed",
			"COzcJxTOzcJxTBcAAAENAiCMAP_AAAAAAAAADTwAQDTgAAAA.IF5EX2S5OI2tho2YdF7BEYYwfJxyigMgShgQIsS8NwIeFbBoGPmAAHBG4JAQAGBAkkACBAQIsHGBcCQABgIgRiRCMQEGMjzNKBJBAggkbI0FACCVmnkHS3ZCY70-6u__bA",
			map[int]bool{1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: true, 10: true, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false, 20: false, 21: false, 22: false, 23: false, 24: false},
			map[int]bool{1: true, 2: true, 3: false, 4: false, 5: false, 6: false, 7: false, 8: false, 9: false, 10: false, 11: false, 12: false},
			423,
			true,
			true,
			true,
			"AA",
			2,
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseCoreString(tt.c)

			if (err != nil) != tt.wantErr {
				t.Errorf("ParseCoreString() error = %v, wantErr %v", err, tt.wantErr)
			}
			if err != nil {
				return
			}

			if got.Version != tt.wantVersion {
				t.Errorf("Version failed. Expected %d, got %d", tt.wantVersion, got.Version)
			}

			if got.Version != 2 {
				return
			}

			if !cmp.Equal(tt.wantPurposes, got.PurposesConsent) {
				t.Errorf("PurposesConsent failed %s", cmp.Diff(tt.wantPurposes, got.PurposesConsent))
			}

			if !cmp.Equal(tt.wantSpecialFeatures, got.SpecialFeatureOptIns) {
				t.Errorf("SpecialFeatureOptIns failed %s", cmp.Diff(tt.wantSpecialFeatures, got.SpecialFeatureOptIns))
			}

			var purposes []int
			for k, v := range tt.wantPurposes {
				if v {
					purposes = append(purposes, k)
				}
			}

			var specialFeatures []int
			for k, v := range tt.wantSpecialFeatures {
				if v {
					specialFeatures = append(specialFeatures, k)
				}
			}

			if pa := got.EveryPurposeAllowed(purposes); pa != tt.wantPurposesAllowed {
				t.Errorf("EveryPurposeAllowed failed. Expected %t, got %t", tt.wantPurposesAllowed, pa)
			}
			if sfa := got.EverySpecialFeatureAllowed(specialFeatures); sfa != tt.wantSpecialFeaturesAllowed {
				t.Errorf("EverySpecialFeatureAllowed failed. Expected %t, got %t", tt.wantSpecialFeaturesAllowed, sfa)
			}
			if va := got.VendorAllowed(tt.wantVendor); va != tt.wantVendorAllowed {
				t.Errorf("VendorAllowed failed. Expected %t, got %t. \nIsRangeEncoding: %t\nVendors: %#v", tt.wantVendorAllowed, va, got.IsRangeEncoding, got.ConsentedVendors)
			}
			if pc := got.PublisherCC; pc != tt.publisherCountry {
				t.Errorf("publisherCountry failed. Expected %s, got %s", tt.publisherCountry, pc)
			}
		})
	}
}

func TestParseCoreString(t *testing.T) {
	tests := []struct {
		name    string
		c       string
		want    *Consent
		wantErr bool
	}{
		{
			"empty",
			"",
			nil,
			true,
		},
		{
			"with values",
			"COzcJxTOzcJxTBcAAAENAiCMAP_AAAAAAAAADTwAQDTgAAAA.IF5EX2S5OI2tho2YdF7BEYYwfJxyigMgShgQIsS8NwIeFbBoGPmAAHBG4JAQAGBAkkACBAQIsHGBcCQABgIgRiRCMQEGMjzNKBJBAggkbI0FACCVmnkHS3ZCY70-6u__bA",
			&Consent{
				Version:                2,
				CMPID:                  92,
				ConsentLanguage:        "EN",
				VendorListVersion:      34,
				TcfPolicyVersion:       2,
				SpecialFeatureOptIns:   map[int]bool{1: true, 2: true, 3: false, 4: false, 5: false, 6: false, 7: false, 8: false, 9: false, 10: false, 11: false, 12: false},
				PurposesConsent:        map[int]bool{1: true, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: true, 10: true, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false, 20: false, 21: false, 22: false, 23: false, 24: false},
				PurposesLITransparency: map[int]bool{1: false, 2: false, 3: false, 4: false, 5: false, 6: false, 7: false, 8: false, 9: false, 10: false, 11: false, 12: false, 13: false, 14: false, 15: false, 16: false, 17: false, 18: false, 19: false, 20: false, 21: false, 22: false, 23: false, 24: false},
				PublisherCC:            "AA",
				MaxVendorID:            423,
				NumEntries:             1,
				IsRangeEncoding:        true,
				RangeEntries:           []*RangeEntry{{StartOrOnlyVendorId: 423, EndVendorID: 423}},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := ParseCoreString(tt.c)
			if (err != nil) != tt.wantErr {
				t.Errorf("ParseCoreString() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if err != nil {
				return
			}
			got.Created = time.Time{}
			got.LastUpdated = time.Time{}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ParseCoreString() failed, %s", cmp.Diff(tt.want, got))
			}
		})
	}
}
